"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenericService = void 0;
const __1 = require("..");
const util_1 = require("../util");
/**
 * @ignore
 */
class GenericService {
    /* istanbul ignore next */
    static getItem(youtube, type, mine, id) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!([__1.Video, __1.Channel, __1.Playlist, __1.YTComment, __1.Subscription, __1.VideoCategory, __1.VideoAbuseReportReason].includes(type))) {
                return Promise.reject('Type must be a video, channel, playlist, comment, subscription, or video category.');
            }
            if (!mine && (id === undefined || id === null)) {
                return Promise.reject('Items must either specify an ID or the \'mine\' parameter.');
            }
            if (mine && (type === __1.YTComment || type === __1.Video)) {
                return Promise.reject(`${type.endpoint} cannot be filtered by the 'mine' parameter.`);
            }
            const cached = util_1.Cache.get(`get://${type.endpoint}/${id ? id : 'mine'}`);
            if (youtube._shouldCache && cached) {
                return cached;
            }
            const result = yield youtube._request.api(type.endpoint, {
                [id ? 'id' : 'mine']: id ? id : mine,
                fields: encodeURIComponent(type.fields),
                part: type === __1.YTComment ? !type.part.includes('snippet') ? type.part + ',snippet' : type.part : type.part
            }, youtube.token, youtube.accessToken);
            if (!result.items || result.items.length === 0) {
                return Promise.reject('Item not found');
            }
            let endResult;
            if (type === __1.YTComment) {
                endResult = new type(youtube, result.items[0], result.items[0].snippet.channelId ? 'channel' : 'video');
            }
            else {
                endResult = new type(youtube, result.items[0]);
            }
            youtube._cache(`get://${type.endpoint}/${id ? id : 'mine'}`, endResult);
            return endResult;
        });
    }
    /* istanbul ignore next */
    static getPaginatedItems(youtube, endpoint, mine, id, maxResults = -1, subId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!mine && (id === undefined || id === null) && endpoint !== 'videoAbuseReportReasons') {
                return Promise.reject(`${endpoint} must either specify an ID or the 'mine' parameter.`);
            }
            if (mine && (endpoint.startsWith('comment') || ['playlistItems', 'videoCategories'].includes(endpoint))) {
                return Promise.reject(`${endpoint} cannot be filtered by the 'mine' parameter.`);
            }
            const cached = util_1.Cache.get(`get://${endpoint}/${id ? id : 'mine'}/${maxResults}`);
            if (youtube._shouldCache && cached) {
                return cached;
            }
            let items = [];
            const full = maxResults <= 0;
            const options = {
                part: 'snippet'
            };
            let max;
            let clazz;
            let commentType;
            if (endpoint === 'playlistItems') {
                max = 50;
                clazz = __1.Video;
                options.playlistId = id;
                if (subId)
                    options.videoId = subId;
            }
            else if (endpoint.startsWith('commentThreads')) {
                max = 100;
                clazz = __1.YTComment;
                const [, type] = endpoint.split(':');
                commentType = type ? type : 'video';
                endpoint = 'commentThreads';
                options[`${type}Id`] = id;
                options.textFormat = 'plainText';
            }
            else if (endpoint === 'comments') {
                max = 100;
                clazz = __1.YTComment;
                options.parentId = id;
            }
            else if (endpoint === 'playlists:channel') {
                max = 50;
                clazz = __1.Playlist;
                endpoint = 'playlists';
                if (mine)
                    options.mine = mine;
                else
                    options.channelId = id;
            }
            else if (endpoint === 'subscriptions') {
                max = 50;
                clazz = __1.Subscription;
                if (mine)
                    options.mine = mine;
                else
                    options.channelId = id;
            }
            else if (endpoint === 'videoCategories') {
                clazz = __1.VideoCategory;
                options.regionCode = id;
            }
            else if (endpoint === 'videoAbuseReportReasons') {
                clazz = __1.VideoAbuseReportReason;
            }
            else {
                return Promise.reject('Unknown item type ' + endpoint);
            }
            if (max && maxResults > max) {
                return Promise.reject(`Max results must be ${max} or below for ${endpoint}`);
            }
            if (max) {
                options.maxResults = full ? max : maxResults;
            }
            let results;
            let pages = null;
            let shouldReturn = !full;
            for (let i = 1; i < pages ? pages : 3; i++) {
                results = yield youtube._request.api(endpoint, options, youtube.token, youtube.accessToken);
                if (results.items.length === 0) {
                    return Promise.reject(`${endpoint} not found`);
                }
                if (!pages) {
                    pages = results.pageInfo ? results.pageInfo.totalResults / results.pageInfo.resultsPerPage : 0;
                    if (pages <= 1) {
                        shouldReturn = true;
                    }
                    pages = Math.floor(pages);
                }
                results.items.forEach(item => {
                    let comment;
                    if (item.snippet.topLevelComment) {
                        comment = new __1.YTComment(youtube, item.snippet.topLevelComment, commentType);
                        items.push(comment);
                    }
                    else {
                        items.push(new clazz(youtube, item, commentType));
                    }
                    if (item.replies) {
                        item.replies.comments.forEach(reply => {
                            const created = new __1.YTComment(youtube, reply, commentType);
                            comment.replies.push(created);
                        });
                    }
                });
                if (results.nextPageToken && !shouldReturn) {
                    options.pageToken = results.nextPageToken;
                }
                else {
                    return items;
                }
            }
            youtube._cache(`get://${endpoint}/${id ? id : 'mine'}/${maxResults}`, items);
            return items;
        });
    }
    /* istanbul ignore next */
    static getId(youtube, input, type) {
        return __awaiter(this, void 0, void 0, function* () {
            let id = null;
            const cached = util_1.Cache.get(`get_id://${type.endpoint}/${input}`);
            if (cached) {
                return cached;
            }
            const cachedEntity = util_1.Cache.get(`get://${type.endpoint}/${input}`);
            if (cachedEntity && cachedEntity.id) {
                return cachedEntity.id;
            }
            if (input.includes('youtube.com') || input.includes('youtu.be')) {
                const idFromUrl = util_1.Parser.parseUrl(input)[type.name.toLowerCase()];
                // Custom channel URLs don't work that well
                if (type === __1.Channel && idFromUrl && !idFromUrl.startsWith('UC')) {
                    id = yield youtube._request.api('search', {
                        q: encodeURIComponent(idFromUrl),
                        type: 'channel',
                        part: 'id'
                    }, youtube.token, youtube.accessToken).then(r => r.items[0] ? r.items[0].id.channelId : undefined);
                }
                id = idFromUrl;
            }
            if (id !== null && id !== undefined && id !== '') {
                return id;
            }
            if (type === __1.Channel && (!input.startsWith('UC') || input.includes(' '))) {
                id = yield youtube._request.api('search', {
                    q: encodeURIComponent(input),
                    type: 'channel',
                    part: 'id', maxResults: 1
                }, youtube.token, youtube.accessToken).then(r => r.items ? (r.items.length > 0 ? r.items[0].id.channelId : undefined) : undefined);
            }
            else if (type === __1.Playlist && input.includes(' ')) {
                id = yield youtube._request.api('search', {
                    q: encodeURIComponent(input),
                    type: 'playlist',
                    part: 'id',
                    maxResults: 1
                }, youtube.token, youtube.accessToken).then(r => r.items ? (r.items.length > 0 ? r.items[0].id.playlistId : undefined) : undefined);
            }
            else if (type === __1.Video && (input.length < 11 || input.includes(' '))) {
                id = yield youtube._request.api('search', {
                    q: encodeURIComponent(input),
                    type: 'video',
                    part: 'id',
                    maxResults: 1
                }, youtube.token, youtube.accessToken).then(r => r.items ? (r.items.length > 0 ? r.items[0].id.videoId : undefined) : undefined);
            }
            if (id === null || id === undefined || id === '') {
                id = input;
            }
            youtube._cache(`get_id://${type.endpoint}/${input}`, id);
            return id;
        });
    }
}
exports.GenericService = GenericService;

//# sourceMappingURL=generic-service.js.map
